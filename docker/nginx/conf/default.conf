server {
    listen 80;

    server_name api.user.local;

    location / {
        resolver 127.0.0.1 valid=30s;
        # This tells NGINX to resolve DNS using the local resolver (127.0.0.1).
        # In Docker, this usually doesn’t work unless you run a DNS service locally.
        # Instead, NGINX inside a Docker network can directly use the service name (user-api) without needing a resolver.
        proxy_pass http://user-api:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        client_max_body_size 20M;
    }
}

server {
    listen      443 ssl; # Listen on port 443 (HTTPS) with SSL and HTTP/2
    http2       on;    # new syntex
    # listen [::]:443 http2 ssl
    server_name   api.user.local; # The domain name (virtual host) for this server block

    ssl_certificate     /ssl/api.user.local.crt;  # Path to your SSL certificate
    ssl_certificate_key /ssl/api.user.local.key;  # Path to your SSL private key

    # Stronger SSL security (optional but recommended)
    # ssl_protocols TLSv1.2 TLSv1.3;  # Only allow TLS 1.2 and 1.3 (disable older, insecure versions)
    # ssl_prefer_server_ciphers on; # Prefer server's cipher order instead of client's
    # ssl_ciphers "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:
    #              ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256"; # Allowed ciphers (secure set for modern TLS)
    # ssl_session_timeout 1d;  # Cache TLS session for 1 day (faster reconnects)
    # ssl_session_cache shared:SSL:10m; # Store up to ~4000 TLS sessions in memory

    location / {
        proxy_pass http://user-api:8080; # Forward all requests to the "user-api" container on port 8080

        proxy_set_header Host $host; # Preserve original Host header
        proxy_set_header X-Real-IP $remote_addr; # Pass client’s real IP
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # Keep proxy chain of client IPs
        proxy_set_header X-Forwarded-Proto $scheme;  # Pass protocol (http/https) to backend

        proxy_http_version 1.1; # Use HTTP/1.1 (needed for WebSockets/keep-alive)
        proxy_set_header Upgrade $http_upgrade; # Enable WebSocket upgrades
        proxy_set_header Connection "upgrade"; # Ensure WebSocket connections upgrade properly

        client_max_body_size 20M;  # Allow request bodies up to 20 MB (e.g., file uploads)
    }
#    location ~ ^\/worklist(\/?)/(.*) {
#        resolver 127.0.0.11 valid=30s;
#        set $dest worklist-api:8080;
#        proxy_request_buffering off;
#        proxy_pass  http://$dest/$2$is_args$args;
#        client_max_body_size 800M;
#        proxy_set_header Host            $host;
#        proxy_set_header X-Forwarded-For $remote_addr;
#        proxy_set_header X-Forwarded-Proto $scheme;
#         # WebSocket support (nginx 1.4)
#        proxy_http_version 1.1;
#        proxy_set_header Upgrade $http_upgrade;
#        proxy_set_header Connection "upgrade";

#        # New settings for long-lived connections
#        proxy_read_timeout 3600s;
#        proxy_send_timeout 3600s;
#        keepalive_timeout 3600s;
#        proxy_buffering off;
#      }
}

server {
  listen        443 ssl;
  server_name   gendocnote.local;

  ssl_certificate     /ssl/api.user.local.crt;  # Path to your SSL certificate
  ssl_certificate_key /ssl/api.user.local.key;  # Path to your SSL private key

  location / {
	resolver 127.0.0.11 valid=30s;
	# set $dest proxy_pass http://host.docker.internal:3000;
	proxy_pass http://host.docker.internal:3000;
	proxy_set_header Host            $host;
	client_max_body_size 20M;
	proxy_set_header X-Forwarded-For $remote_addr;
	proxy_set_header X-Forwarded-Proto $scheme;
  }
}